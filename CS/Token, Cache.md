# Token, Cache

[TOC]



## 캐시(Cache)

#### 캐시란?

숨기다라는 뜻의 cacher에서 파생된 단어로, 기술적으로는 웹 페이지 요소를 저장하기 위한 임시 저장소

#### 왜 사용할까?

캐시의 접근 시간에 비해 원래 데이터를 접근하는 시간이 오래 걸리는 경우나 값을 다시 계산하는 시간을 절약하고 싶은 경우에 사용한다.

캐시에 데이터를 미리 복사해 놓으면 계산이나 접근 시간 없이 더 빠른 속도로 데이터에 접근 가능하다.

- 예시
  - 접근 시간에 비해 원래 데이터를 접근하는 시간이 오래 걸리는 경우(서버의 균일한 API 데이터)
  - 반복적으로 동일한 결과를 돌려주는 경우(이미지나 썸네일 등)

**Cache란 반복적으로 데이터를 불러오는 경우에, 지속적으로 DBMS 혹은 서버에 요청하는 것이 아니라 Memory에 데이터를 저장하였다가 불러다 쓰는 것을 의미한다.**

#### 사용 예시

- 브라우저 캐시
  - 사용자가 인터넷 서핑을 할 때 받아온 데이터는 브라우저에 캐시 형태로 저장된다.
  - 쿠키와 같이 캐시도 각 브라우저의 설정 화면에서 조작해 비울 수 있다.
  - 캐시 덕분에 사용자는 같은 사이트를 재방문 하거나 동영상을 재시청할 때 추가로 통신비를 지출하지 않고 로딩 없이 콘텐츠 이용이 가능하다.
- CPU 캐시
  - 캐시는 인터넷 환경 뿐 아니라 다양한 곳에서 사용되는 개념이다.
  - 컴퓨터의 하드웨어 안에서도 메모리 안에 있는 정보를 더 빨리 가져올 수 있도록 CPU 캐시등을 활용한다.

#### 쿠키 VS 캐시?

쿠키와 캐시 모두 정보를 저장하여 재활용하는 기술

쿠키는 사용자의 수고를 덜어주는 데 목적을 두고, 

**캐시는 데이터의 전송량을 줄이고 서비스 이용 속도를 높이는 데 목적**을 둔다.

### 참고

#### 지역성

모든 데이터를 캐시에 담기에는 저장 공간이 크지 않기 때문에 힘들다.

그렇기에 캐시는 보통 지역성을 나눠 분류한다.

1. 시간적 지역성
   - **특정 데이터가 한 번 접근되었을 경우 가까운 미래에 또 한 번 데이터에 접근할 가능성이 높은 것**을 말한다.
   - 캐시에 한 번 가져와서 저장하고 여러 번 사용하게 되면 메모리에 접근하는 횟수가 줄어든다.
   - 따라서 반복적으로 사용되는 데이터가 많을수록 캐시는 높은 효율성을 낼 수 있다.
2. 공간적 지역성
   - **특정 데이터와 가까운 주소가 순서대로 접근되었을 경우** 공간적 지역성이라고 한다.
   - CPU  캐시나 디스크 캐시의 경우, 한 메모리 주소에 접근할 때 그 주소 뿐 아니라 해당 블록을 전부 캐시에 가져오게 된다.
   - 이 때 메모리 주소를 오름차순이나 내림차순으로 접근한다면 캐시에 이미 저장된 같은 블록의 데이터를 접근하게 되므로 캐시의 효율성이 크게 향상된다.
   - 앞으로 사용할 데이터들이 가져올 블록 안에 모여있는 것을 말하는 것. 필**요한 데이터가 모여있다면 한번만 메모리에 접근해도 필요한 데이터들을 가져올 수 있다**.
   - 데이터가 모여있지 않다면 Cache Miss가 날 확률이 높고 효율성이 떨어진다.





## 토큰(token)

`토큰` : 소프트웨어 또는 하드웨어에서 **어떤 작업을 수행할 수 있는 권한을 나타내는 객체**

세션과 마찬가지로 로그인을 유지하고 서버에 사용자를 인증할 수 있는 수단으로 사용된다.

최근 들어 더 안정적이고 모바일 환경에 적합한 인증 방법으로 토큰 기반 인증이 많이 사용되고 있는 추세이다.

인증, 암호화 등 중요 작업에 많이 사용된다.

#### 왜 세션보다 토큰?

로그인 시 쿠키/세션 방식을 사용하면, 

- 쿠키를 중간에서 가로채서 치명적인 **보안 문제**를 일으킬 수도 있다.
- 서버는 수많은 사용자의 세션을 저장하고 요청이 들어올 때마다 확인 작업을 하느라, **서버의 부담**이 커진다.

토큰 기반 인증은 세션/쿠키 방식보다 보안성도 높고 서버에게도 효율적인 방식이다.

#### 장점

세션에서처럼 서버에 유저의 정보를 저장할 필요가 없다(상태를 따로 기억해 둘 필요가 없음)

서버는 토큰에 대한 검증만 수행하면 되기 때문에 서버에 부담이 적은 방식

#### access token, refresh token

`Access Token` : 출입증 역할, API를 사용하기 위한 인증용 토큰

`Refresh Token` : Access token이 만료되었을 때 인증 상태를 연장해 줄 토큰

토큰은 웹 브라우저 측에 저장되기 때문에 공격에 노출될 가능성이 더 크다.

이런 경우를 대비해 토큰에는 민감한 정보를 담지 않고, 유효기간을 짧게 설정해 공격에 노출될 수 있는 시간을 최소화한다. (access token)



### JWT

Json Web Token

JSON 객체를 사용해 가벼운 방식으로 정보를 안정성 있게 전달해주기 위한 토큰

#### 왜 JWT?

사실 기본적인 인증을 진행하는 구조는 쿠키와 크게 다르지 않다.

다만, JWT는 **서명된 토큰**이라는 점에서 차이가 있다.

공개/개인 키를 쌍으로 사용하여 토큰에 서명할 경우 서명된 토큰은 개인 키를 보유한 서버가 이 서명된 토큰이 정상적인 토큰인지 인증할 수 있다.

#### 구조

![image-20230707002946055](Token,%20Cache.assets/image-20230707002946055.png)

1. Header

   ```JSON
   {
   	"typ": "JWT",
   	"alg": "HS512"
   }
   ```

   - Header에는 보통 토큰의 타입이나, 서명 생성에 어떤 알고리즘이 사용됐는지 저장

2. Payload

   ```json
   {
       "sub": "1",
       "iss": "ori",
       "exp": 1636989718,
       "iat": 1636989718
   }
   ```

   - payload에는 보통 Claim이라는 사용자에 대한, 혹은 토큰에 대한 property를 key-value의 형태로 저장한다.
   - Claim이라는 말 그대로 토큰에서 사용할 정보의 조각
   - 표준 스펙 상 key의 이름은 3글자이고, 사용자와 토큰에 대한 표현을 압축한 것
     - iss(Issuer): 토큰 발급자
     - sub(Subjec): 토큰 제목 - 토큰에서 사용자에 대한 식별 값이 됨
     - aud(Audience): 토큰 대상자
     - exp(Expiration Time): 토큰 만료 시간
     - nbf(Not Before): 토큰 활성 날짜(이 날짜 이전의 토큰은 활성화되지 않음을 보장)
     - iat(Issued At): 토큰 발급 시간
     - jti(JWT Id): JWT 토큰 식별자(issuer가 여러 명일 때 이를 구분하기 위한 값)
   - payload는 디코딩 되어있을 뿐이지 특별한 암호화가 걸려있는 것이 아니기 때문에 누구가 jwt를 가지고 디코딩 한다면 header나 payload에 담긴 값을 알 수 있다. 그러므로 단순히 식별을 하기 위한 정보만 담아야 한다. 민감한 개인 정보 안됨!

3. Signature

   ![image-20230707003953152](Token,%20Cache.assets/image-20230707003953152.png)

   위는 Signature를 디코딩 했을 때 볼 수 있는 화면

   - `header 디코딩 값` + `payload 디코딩 값` + `your-256-bit-secret` : 서버가 가지고 잇는 개인키로 암호화 되어있는 상태
   - 따라서 signature는 서버에 있는 개인키로만 암호화를 풀 수 있으므로 다른 클라이언트는 임의로 Signature를 복호화할 수 없다.

#### 복호화 인증 방법

1. JWT 토큰을 클라이언트가 서버로 요청과 동시에 전달한다.
2. 서버가 가지고 있는 개인키를 가지고 Signature를 복호화한 다음, base64UrlEncode(header)가 JWT의 header값과 일치하는 지, base64UrlEncode(payload)와 일치하는 지 확인하여 일치한다면 인증을 허용한다.
3. 만약 클라이언트가 payload에 담긴 식별자가 변조된 JWT로 요청을 하더라도 서버가 애초에 발급했던 Signature안의 payload와 다르기 때문에 인증이 불가능해진다.

#### 인가 프로세스

![image-20230706235450321](Token,%20Cache.assets/image-20230706235450321.png)

1. 클라이언트 로그인 요청이 들어오면, 서버는 검증 후 클라이언트의 고유한 ID등의 정보를 payload에 담는다.
2. JWT의 유효기간을 설정하고 secret키를 이용해 access token(JWT)을 발급한다.
3. 클라이언트는 access token(JWT)을 받아 저장한 후 인증이 필요할 때마다 토큰을 요청 헤더 Authorization에 포함시켜 함께 전달한다.
4. 서버에서는 해당 토큰 signature를 secret 키로 복호화한 후, 위변조 여부 및 유효 기간을 확인한다.
   - 여기서 secret 키가 매우 중요한 역할을 하는데, 만약 JWT가 탈취당한 상황이라고 하더라도 상대방이 secret키를 모른다면 검증단계에서 걸러지게 하는 보안적으로 중요한 역할이다.
5. 검증이 완료되고 유효한 토큰이라면,  payload를 디코딩하여 사용자의 ID에 맞는 데이터를 가져온다.











## Reference

- https://jminie.tistory.com/125#7.%20%F0%9F%93%8C%C2%A0%20%EC%BA%90%EC%8B%9C
- https://dev-coco.tistory.com/61
- https://hongong.hanbit.co.kr/%EC%99%84%EB%B2%BD-%EC%A0%95%EB%A6%AC-%EC%BF%A0%ED%82%A4-%EC%84%B8%EC%85%98-%ED%86%A0%ED%81%B0-%EC%BA%90%EC%8B%9C-%EA%B7%B8%EB%A6%AC%EA%B3%A0-cdn/
- https://zorba91.tistory.com/163
- https://jeongkyun-it.tistory.com/173
- https://velog.io/@vamos_eon/JWT%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94%EA%B0%80-%EC%82%AC%EC%9A%A9%EC%B2%982

- https://brunch.co.kr/@jinyoungchoi95/1