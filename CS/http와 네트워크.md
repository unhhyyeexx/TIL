# HTTP

HTTP는 HyperText Transfer Protocol의 약자로 데이터를 주고받기 위해 정의한 통신 프로토콜(규약)

웹을 기준으로 브라우저와 서버 간에 데이터를 주고받기 위한 방식으로 http프로토콜을 사용한다.

### 특징

1. **Connectionless 프로토콜** **(비연결 지향)**
   - 클라이언트가 서버에 요청(Request)을 했을 때, 그 요청에 맞는 응답(Response)을 보낸 후 **연결을 끊는** 처리방식
   - http1.1버전에서 커넥션을 계속 유지하고, 요청에 재활용하는 기능이 추가되었다. (http Header)에 keep-alive 옵션을 주어 커넥션을 재활용하게 한다. http1.1버전에서 디폴트 옵션이다.
   - http가 tcp 위에서 구현된었기 때문에 (TCP: 연결지향, UDP: 비연결 지향) 연결 지향적이라고 할 수 있다는 얘기가 있어 논란이 있지만, 아직까진 네트워크 관점에서 keep-alive는 옵션으로 두고, 서버 측에서 비연결 지향적인 특성으로 커넷션 관리에 대한 비용을 줄이는 것이 명확한 장점으로 보기 때문에 비연결 지향으로 알아두었다.

2. **상태가 없는(stateless)** 프로토콜

   - 상태가 없다 == 데이터를 주고받기 위한 각각의 데이터 요청이 서로 독립적으로 관리가 된다.
     즉, 이전에 보냈던 데이터 요청과 다음에 보낼 데이터 요청이 서로 관련이 없다는 의미

   - 이러한 특징 덕분에 서버는 세션과 같은 별도의 추가 정보를 관리하지 않아도 되고, 다수의 요청 처리 및 서버의 부하를 줄일 수 있는 성능 상의 이점이 생긴다.
   - 커넥션을 끊는 순간 클라이언트와 서버의 통신이 끝나며 상태 정보는 유지하지 않는 특성 덕분에 클라이언트와 첫 번째 통신에서 데이터를 주고 받았다고 해도, 두 번째 통신에서 이전 데이터를 유지하지 않는다.
     하지만 실제로는 데이터 유지가 필요한 경우가많다.

   > 정보가 유지되지 않으면 매번 페이지를 이동할 때마다 로그인을 다시 하거나, 
   > 상품을 선택했는데 구매 페이지에서 선택한 상품의 정보가 없거나 하는 등의 일이 발생할 수 있다.
   > -> 따라서 stateful경우를 대처하기 위해 쿠키와 세션을 사용한다.
   > -> 쿠키와 세션의 차이점은 크게 상태 정보의 저장위치로, 
   >     쿠키는 클라이언트(로컬pc)에 저장하고, 세션은 서버에 저장한다.

http프로토콜은 일반적으로 TCP/IP 통신 위에서 동작하며 기본 포트는 80번이다.

### URL?

URL(Uniform Resource Locators)은 서버에 자원(resource)를 요청하기 위해 입력하는 영문 주소이다.

숫자로 되어있는 ip주소보다는 훨씬 기억하기 쉬운 이점

브라우저에서는 이렇게 url로 되어있는 http요청은 DNS(Domain Name System)를 통해 host에 해당하는 실제 IP주소로 변환하여 서버에 요청(Request)를 보낸다.

![image-20230225011928296](http%EC%99%80%20%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC.assets/image-20230225011928296-16772555694571.png)

1. Protocol
   - url의 첫 파트이자 웹에서 서버와 클라이언트 간에 어떤 방법으로 자원을 접근할 지 알려준다.
   - 요즘 https를 기본 프로토콜로 사용하는데, http에 보안이 강화된 버전이다.
   - 브라우저에서 가장 많이 사용되는 https/http외에도 mailto: (이메일 주소를 지정하는 프로토콜), ftp:  (파일을 주고받는 프로토콜) 등 다양한 프로토콜이 존재
2. Domain Name
   - 도메인 네임은 url에서 웹 서버의 위치를 지정한다.
   - 직접 ip주소(ex. 127.0.0.1)를 사용하는 것도 가능
3. Port
   - 웹 서버에서 자원을 접근하기 위하여 사용하는 관문
   - 표준 http포트는 80번, https는 443이다. 표준 포트를 사용한다면 포트 번호는 보통 생략한다.
4. Path
   - 웹 섭버에서 자원에 대한 경로
   - 초기의 웹에서는 웹서버상에서 물리적 파일 위치를 나타냈지만, 지금은 실제 물리적 경로를 나타내지 않고, 웹 서버에서 추상화하여 보여준다.
   - 루트 자원을 나타내려면 "/"을 사용한다.
5. Query Parameters
   - &기호로 구분되니 키/값으로 짝을 이룬 리스트
   - 키와 값은 = 문자로 구분한다.
6. Fragment identifier(Anchor)
   - 세부 항목에 대한 책갈피 역할
   - ex. 특정 스크롤 위치로 이동(목차 등)
   - 요청이 서버에 보내지지 않음



# 네트워크

TCP/IP 란 인터넷에 관련된 다양한 프로토콜의 집합

### 애플리케이션 계층

- **HTTP프로토콜** 사용
- 리퀘스트 요청 및 처리
- DNS로 도메인명에서 IP주소로 변환해주는 역할

### 전송계층

- **TCP프로토콜** 사용
- 대용량의 데이터를 보내기 쉽게 작게 **분해(패킷)**하여 상대에게 보냈고,
- 정확하게 **도착했는지 확인**하는 역할(쓰리웨이 핸드셰이킹: 클라-보냈음 => 서버-받았음 => 클라-OK완료)

### 네트워크 계층

- **IP프로토콜** 사용
- 패킷들을 운반시키는 역할
- 여러곳들을 경유
- **최적의 경로**를 결정

### 링크 계층

- 데이터를 받는 하드웨어



# 통신의 과정

- 클라이언트
  - 애플리케이션(http) : http 요청 메시지 작성, 도메인은 ip로 변경
  - 전송계층(tcp) : http 요청 메시지 패킷으로 분해. 서버에게 전송
- 인터넷
  - 네트워크 계층(ip) : 여러 컴퓨터, 네트워크 기기들을 경유하며 패킷을 전달
- 서버
  - 링크계층 : 서버 컴퓨터에 도착
  - 전송계층(tcp) : 패킷 조립
  - 어플리케이션(http): http 요청 메시지를 보고 요청 처리



# http의 버전

##### http 1.0

**TCP 연결은 한 요청 단위**임. 연결이 되면 패킷들을 전송

그러나 요즘에는 **한 웹페이지를 구성하기 위하여 많은 리소스**가 필요하다.

##### http 1.1

HTML에 연결된 많은 리소스를 요청할 때마다 연결하고 끊고 하기 너무 번거롭고 느리다.

그래서 HTTP1.1에 한 연결에 여러 요청을 할 수 있는 **지속 연결** 기능과
여러 요청을 병행적으로 할 수 있는 **파이프라인** 기능,
데이터 압축 / 압축 해제 등의 기능이 추가되어 속도가 개선됨

##### http 2.0

http1.1의 성능을 개선했다. 가장 큰 차이는 속도.
2.0 같은 경우는 헤더를 압축해서 보내기도 하고, 한 번의 연결로 동시에 여러 메시지를 주고 받을 수 있다.

1. **Multiplexed Streams**
   - Pipelining의 개선 버전.
   - Pipelining은 요청은 병행할 수 있지만, 응답은 요청 순서에 따라 받아야 한다. 
   - Multiplexed Streams은 **응답을 요청 순서에 상관없이 Stream으로 받기** 때문에 HOL Bloking이 발생하지 않는다.
2. **Stream Prioritization**
   - **리소스 간의 의존관계에 따른 우선순위**를 설정하여 리소스 로드 문제를 해결한다.
     (EX - img파일보다 css가 먼저 도착해야 함)
3. **Server Push**
   - 서버는 **클라이언트가 요청하지 않은 리소스를 사전에 푸쉬를 통해 전송**할 수 있다.
     예를 들어 클라이언트가 html문서를 요청하면 서버가 html에 담긴 리소스들까지 알아서 보내주기 때문에 클라이언트의 요청을 최소화할 수가 있다.

### 전송 메시지 구성

데이터 전송 단위인 패킷에 요청/응답에 대한 메시지가 담겨있다.

- 시작라인 (Request / Response Line)
  - method / 상태 코드, URI, http 버전
- 헤더 (Header)
  - 일반 헤더 - 요청 및 응답 메시지 모두에서 사용 가능한 일반 목적의(기본적인) 헤더 항목
  - request/response 헤더 - 클라/서버에 대한 정보 + 요청/응답에 대한 정보
  - Entity 헤더 - Body에 담긴 데이터에 대한 정보
- 본문 (Body)
  - 데이터

### 헤더의 종류와 주요 필드

##### 일반 헤더

- **cache-control** : 캐시 동작 지정
- **connection**: 클라와 서버간 연결에 대한 옵션 설정(close/keep-alive)
- **date**: 메시지 생성 날짜

##### request 헤더

- **Host**: 요청하는 호스트에 대한 호스트명 및 포트 번호
- **User-Agent**: 클라이언트 정보
- **Authorization**: 인증 토큰 (JWT/Bearer 토큰)을 서버로 보낼 때 사용하는 헤더
- **Cookie**: 서버에 의해 Set-Cookie로 클라이언트에게 설정된 쿠키 정보
- **Origin**: 요청이 어느 주소에서 시작되었는지 나타낸다. 
  요청을 보낸 주소와 응답의 주소가 다르면 CORS에러가 발생한다.
- **Accept**: 클라이언트 자신이 원하는 미디어 타입 및 우선순위
- **Accept-charset**: 클라이언트 자신이 원하는 문자 집합
- **Accept-Encoding**: 클라이언트 자신이 원하는 문자 인코딩 방식
- **Accept-Lenguage**: 클라이언트 자신이 원하는 가능한 언어

##### response 헤더

- **Server**: 서버정보
- **Set-Cookie**: 클라이언트에게 세션 쿠키 정보(사용자 인증 정보)를 전달
- **Allow**: 해당 자원에 대해 서버 측에서 지원 가능한 http 메소드의 리스트, 때론, http메소드 options에 대한 응답용 항목으로 사용된다.
- **Access-Control-Allow-Origin**: 요청을 보내는 프론트 주소와 받는 백엔드 주소가 다르면 CORS에러가 발생한다.
  서버에서 이 헤더에 허용하는 프론트 주소를 적어주어야 에러가 나지 않는다. 
  *를 사용하여 모든 주소를 허용할 수도 있다.

##### Entity 헤더

body에 실린 Entity(콘텐츠, 본문, 리소스 등)에 대한 설명

- **Content-Type**: 데이터의 미디어 타입 정보 + 인코딩 방식 지정
- **Content-Language**: 
- **Content-Encoding**: 데이터 압축 방식
- **Content-Length**: 데이터의 바이트 길이 또는 크기
- **Content-Location**: 데이터의 실제 위치
- **Location**: 리다이렉트 되어야 할 때 어느곳으로 이동할 지 명시



# HTTP VS HTTPS

HTTPS는 HTTP에 데이터 암호화가 추가된 프로토콜이다.

HTTPS는 HTTP(80번)와 다르게 443포트를 사용하며, 네트워크 상에서 중간에 제 3자가 정보를 볼 수 없도록 **공개키 암호화를 지원**한다.

HTTPS를 사용할 경우 내가 브라우저를 통해 입력하는 정보를 (ex: form data) 다른 누군가가 훔쳐보지 못하게 한다.

HTTP: 입력한 정보를 보낼 경우, 입력한 형태 그대로 보내짐

```
id: my_naver_id
pw: my_naver_pw
```

따라서 누군가가 악의적으로 이 요청을 캐치해서 내 정보를 들여다 본다면, 그대로 아이디와 비번이 노출될 수 있다.

하지만 HTTPS를 사용할 경우, 이 통신 요청(request)을 보낼 때 응답(response)을 해주는 서버만 알아볼 수 있도록 정보를 암호화해서 보내게 된다. 아래는 예시.

```
id: ^!@#$%*#&_SA(_A#@)
pw: !@@^$@^_SS#
```

또한 HTTPS는 기관으로부터 검증된 사이트만 주소에 HTTPS사용이 허가되기 때문에, 내가 접속한 사이트가 상대적으로 안전한 주소를 가졌음을 증명하는 것이기도 하다.

> 결정적 차이는 보안
>
> 1. http 방식은 네트워크 상에서 정보를 누군가가 마음대로 열람, 수정이 가능, 
>    https는 누가 볼 수 없도록 막는다.
> 2. http방식이 https방식보다 빠르다.
> 3. http방식은 민감한 정보를 다룰 때 항상 변조, 해킹 가능성을 염두에 두어야 한다.
>    https는 설치 및 인증서를 유지하는데 추가적인 비용이 발생한다.
>
> -> 따라서, 민감한 정보가 있는 페이지의 경우 https, 그럴 필요가 없다면 http로 만들면 된다.