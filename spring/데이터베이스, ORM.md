# 데이터베이스, ORM

[TOC]



### DBMS

database management system

데이터베이스 : 구조화된 정보 또는 데이터의 조직화된 모음

DBMS: 데이터베이스를 관리하기 위한 소프트웨어



#### 관계형 DBMS

== RDBMS(relational DBMS)

테이블 형태로 이루어진 데이터 저장소



#### H2

자바로 작성되어 있는 RDBMS

- 스프링 부트가 지원하는 인메모리 관계형 데이터베이스
- 데이터를 다른 공간에 따로 보관하는 것이 아니라 애플리케이션 자체 내부에 데이터를 저장하는 특징
- 따라서 애플리케이션을 다시 실행하면 데이터는 초기화
- 간편하게 사용하기 좋아서 개발 시에 테스트 용도로 많이 사용한다. 실제 서비스에는 사용하지 않음





### ORM

object-relational mapping

자바의 객체와 데이터베이스를 연결하는 프로그래밍 기법

- 장점
  - sql을 직접 작성하지 않고 사용하는 언어로 데이터베이스에 접근할 수 있다.
  - 객체지향적으로 코드를 작성할 수 있기 때문에 비즈니스로 로직에만 집중할 수 있다.
  - 데이터베이스 시스템이 추상화되어 있기 때문에 MySQL에서 PostgreSQL로 전환한다고 해도 추가로 드는 작업이 거의 없다. 즉, 데이터베이스 시스템에 대한 종속성이 줄어든다.
  - 매핑하는 정보가 명활하기 때문에 ERD에 대한 의존도를 낮출 수 있고 유지보수할 때 유리하다.
- 단점
  - 프로젝트의 복잡성이 커질수록 사용 난이도가 올라간다
  - 복잡하고 무거운 쿼리는 ORM으로 해결이 불가능한 경우가 있다.





### JPA

자바에서 ORM은 JPA(java persistence API)를 표준으로 사용한다.

JPA는 자바에서 관계형 데이터베이스를 사용하는 방식을 정의한 인터페이스로, 인터페이스이므로 실제 사용을 위해서는 ORM 프레임워크를 추가로 선택해야 한다.

- 대표적으로는 하이버네이트(hibernate)를 많이 사용하고, 하이버네이트는 JPA 인터페이스를 구현한 구현체이자 자바용 ORM프레임워크, 내부적으로는 JDBC API를 사용한다.
- 하이버네이트의 목표는 자바 객체를 통해 데이터베이스 종류에 상관없이 데이터베이스를 자유자재로 사용할 수 있게 하는데 있다.



#### 엔티티 매니저

**엔티티** : 데이터베이스의 테이블과 매핑되는 객체

- 본질적으로는 자바 객체이므로 일반 객체와 다르지 않다.
- 하지만 데이터베이스의 테이블과 직접 연결된다는 아주 특별한 특징이 있어 구분지어 부른다.
- 즉, 엔티티는 객체이긴 하지만 데이터베이스에 영향을 미치는 쿼리를 실행하는 객체

**엔티티 매니저** : 엔티티를 관리해 데이터베이스와 어플리케이션 사이에서 객체를 생성, 수정, 삭제하는 역할

- 이런 엔티티 매니저를 만드는 곳은 엔티티 매니저 팩토리



#### 영속성 컨텍스트

엔티티 매니저는 엔티티를 영속성 컨텍스트에 저장한다는 특징이 있다.

**영속성 컨텍스트** : JPA의 중요한 특징 중 하나로, 엔티티를 관리하는 가상의 공간.

**특징** (데이터베이스의 접근을 최소화해 성능을 높인다)

- 1차 캐시 
  - 영속성 컨텍스트는 내부에 1차 캐시를 가지고 있다. 
  - 이때 캐시의 키는 엔티티의 @Id 애너테이션이 달린 기본키 역할을 하는 식별자이며 값은 엔티티
  - 엔티티를 조회하면 1차 캐시에서 데이터를 조회하고 값이 있으면 반환한다.
  - 값이 없으면 데이터베이스에서 조회해 1차 캐시에 저장한 다음 반환한다.
  - 이를 통해 캐시된 데이터를 조회할 때에는 데이터베이스를 거치지 않아도 되므로 매우 빠르게 데이터를 조회할 수 있다.

- 쓰기 지연
  - transactional write-behind
  - 트랜잭션을 커밋하기 전까지는 데이터베이스에 실제로 질의문을 보내지 않고 쿼리를 모았다가 트랜잭션을 커밋하면 모았던 쿼리를 한번에 실행하는 것을 의미한다.
  - 예들 들어, 데이터 추가 쿼리가 3개라면 영속성 컨텍스트는 트랜잭션을 커밋하는 시점에 3개의 쿼리를 한꺼번에 전송한다. 
  - 적당한 묶음으로 쿼리를 요청할 수 있어 데이터베이스 시스템의 부담을 줄일 수 있다.
- 변경 감지
  - 트랜잭션을 커밋하면 1차 캐시에 저장되어 있는 엔티티의 값과 현재 엔티티의 값을 비교해서 변경된 값이 있다면 변경 사항을 감지해 변경된 값을 데이터베이스에 자동으로 반영한다.
  - 이를 통해 쓰기지연과 마찬가지로 적당한 묶음으로 쿼리를 요청할 수 있고, 데이터 베이스 시스템의 부담을 줄일 수 있다.

- 지연 로딩
  - lazy loading
  - 쿼리로 요청한 데이터를 애플리케이션에 바로 로딩하는 것이 아니라 필요할 때 쿼리를 날려 데이터를 조회하는 것을 의미한다.
  - 반대로 조회할 때 쿼리를 보내 연관된 모든 데이터를 가져오는 즉시 로딩도 있음



#### 엔티티의 상태

엔티티는 4가지의 상태를 가진다.

1. 영속성 컨텍스트가 관리하고 있지 않는 분리(detached)상태
2. 영속성 컨텍스트가 관리하는 관리(managed)상태
3. 영속성 컨텍스트와 전혀 관계가 없는 비영속(transient)상태
4. 삭제된(removed)상태

```java
// entity 상태 변경 예

public class EntityManagerTest {
    
    @Autowired
    EntityManager em;
    
    public void example() {
        // 1. 엔티티매니저가 엔티티를 관리하지 않는 상태(비영속 상태)
        Member member = new Member(1L, "kiki");
        
        // 2. 엔티티가 관리 상태가 된다.(관리 상태)
        em.persist(member);
        // 3. 엔티티 객체가 분리된 상태가 된다(분리 상태)
        em.detach(member);
        // 4. 엔티티 객체가 삭제된 상태가 된다(삭제 상태)
        em.remove(member);
    }
}

// 1. 엔티티를 처음 만들면 엔티티는 비영속 상태가 된다
// 2. persist() 메서드를 사용해 엔티티를 관리 상태로 만들 수 있으며, Member 객체는 영속성 컨텍스트에서 상태가 관리된다.
// 3. 만약 엔티티를 영속성 컨텍스트에서 관리하고 싶지 않다면 detach() 메서드를 사용해 분리 상태로 만들 수 있다.
// 4. 또한 더 이상 객체가 필요 없다면 remove() 메서드를 사용해서 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제할 수 있다.
```





### 스프링 데이터와 스프링 데이터 JPA

- 스프링 데이터 
  - 비즈니스 로직에 더 집중할 수 있게 데이터베이스 사용 기능을 클래스 레벨에서 추상화했다.
  - 스프링 데이터에서 제공하는 인터페이스를 통해서 스프링 데이터를 사용할 수 있다.
  - 이 인터페이스에서는 CRUD를 포함한 여러 메서드가 포함되어 있으며, 알아서 쿼리를 만들어 준다.
  - 또한 페이징 처리 기능과 메서드 이름으로 자동으로 쿼리 빌딩하는 기능이 제공되는 등 많은 장점
  - 추가로 각 데이터베이스의 특성에 맞춰 기능을 확장해ㅐ 제공하는 기술도 제공



#### 스프링 데이터 JPA

스프링 데이터의 공통적인 기능에서 JPA의 유용한 기술이 추가된 기술이다.

스프링데이터의 인터페이스인 PaigingAndSortingRepository를 상속받아 JpaRepository 인터페이스를 만들었으며, JPA를 더 편리하게 사용하는 메서드를 제공한다.

```java
// 메서드 호출로 엔티티 상태 변경 예

@PersistenceContext
EntityManager em;

public void join() {
    // 기존에 엔티티 상태를 바꾸는 방법(메서드 호출을 해서 상태 변경)
    Member member = new Member(1L, "kiki");
    em.persist(member);
}
```

위와같이 메서드 호출을 통해 엔티티 상태를 바꾸는 것이 스프링 데이터 JPA를 사용하면 리포지터리 역할을 하는 인터페이스를 만들어 데이터베이스의 테이블 조회, 수정, 생성, 삭제 같은 작업을 간단히 할 수 있다.

다음과 같이 JpaRepository 인터페이스를 우리가 만든 인터페이스에서 상속받고 제네릭에는 관리한 **<엔티티 이름, 엔티티 기본키의 타입>**을 입력하면 기본 CRUD를 위해 만든 메서드를 사용할 수 있다.

```java
// 기본 CRUD 메서드를 사용하기 위한 JpaRepository 상속 예

public interface MemberRepository extends JpaRepository<Member, Long> {
}
```

